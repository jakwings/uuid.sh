#!/bin/sh

# Copyright (C) 2022 by J.W https://github.com/jakwings/uuid.sh
#
#   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.

set -euf; unset -v IFS; export LC_ALL=C

# copy-able text should go to fd 3
exec 3>&1 1>&2

# Specifications:
# - https://tools.ietf.org/html/rfc4122
# - https://www.rfc-editor.org/rfc/inline-errata/rfc4122.html
# - https://pubs.opengroup.org/onlinepubs/9696989899/chap5.htm#tagcjh_08_02_01_01
# - https://tools.ietf.org/html/draft-peabody-dispatch-new-uuid-format-04
# Some proposed namespace UUIDs:
# - 6ba7b810-9dad-11d1-80b4-00c04fd430c8 Fully-Qualified Domain Name (FQDN, DNS)
# - 6ba7b811-9dad-11d1-80b4-00c04fd430c8 Uniform Resource Locator (URL)
# - 6ba7b812-9dad-11d1-80b4-00c04fd430c8 ISO Object Identifier (ISO OID)
# - 6ba7b814-9dad-11d1-80b4-00c04fd430c8 X.500 Distinguished Name (X.500 DN)
# These two special IDs make no sense for this program:
# - 00000000-0000-0000-0000-000000000000
# - ffffffff-ffff-ffff-ffff-ffffffffffff
help() {
  printf '%s' 'uuid.sh -- a UUID Generator in POSIX Shell

Usage:
    uuid [<options>] [<version> [<arguments>]]
        Generate a Universally Unique Identifier.
        The default version to use is "v4".

Options:
    -h, --help
        Show this help information.
    -b, --binary
        Output bytes in binary instead of plain-text format.
    -d, --decode
        Extract data from UUIDs generated by this program.
    -g, --guid
        Output variant-2 UUIDs by costing 1 bit of randomness.
    -n, --next
        Output the next UUID for version 1, 2 or 6.
    -s, --seed <number>
        Use a deterministic pseudo-random number generator.
    -l, --lowercase
        Use lower-case letters for UUID output in plain text.
    -u, --uppercase
        Use upper-case letters for UUID output in plain text.

Summary of available versions:
    uuid v0 [<uuid>]
        ... Output key=value pairs for sourcing when -d flag is on ...
    uuid v1 [<period> [<sequence> [<node>]]]
        ... Gregorian timestamp plus privacy and security concerns ...
    uuid v2 <domain> <identifier> [<period> [<sequence> [<node>]]]
        ... v1 of less available IDs per clock tick but DCE Security ...
    uuid v3 <uuid> <text>...
        ... 16 bytes of 6 fixed bits from a 16-byte MD5 hash ...
    uuid v4 [<count>]
        ... 16 (pseudo-)random bytes of 6 predetermined bits ...
    uuid v5 <uuid> <text>...
        ... 16 bytes of 6 fixed bits from a 20-byte SHA-1 hash ...
    uuid v6 [<period> [<sequence> [<node>]]]
        ... Draft#3: lexicographically sortable by Gregorian timestamp ...
    uuid v7 [<millisecond> [<random1> [<random2>]]]
        ... Draft#3: lexicographically sortable by Unix Epoch timestamp ...
    uuid v8 [<year> [<month> [<day> [<hour> [<minute> [<node>]]]]]]
        ... Draft#3: lexicographically sortable by custom timestamp ...

Notes:
    For time-based UUIDs, users must provide a system-wide global guard
    to avoid race conditions among generators runing at the same time.
    Please reference section 4.2 of RFC4122 for useful tips.
    https://www.rfc-editor.org/rfc/inline-errata/rfc4122.html
'
}

echo() {
  printf '%s\n' "$*"
}
ekho() {
  printf '[ERROR] %s\n' "$*"
}
die() {
  exitcode="$(( ($?) ? ($?) : 1 ))"
  [ 0 -ge "$#" ] || ekho "$@" >&2
  exit "${exitcode}"
}

have() {
  [ -x "$(command -v "$1" 2>/dev/null)" ]
}
case_in() {
  eval "! case \"\$1\" in (${2:-\"\"}) false; esac"
}


# PCG Random Number Generation ported to POSIX shell {
#
# Notice from original implementation in the C programming language:
#
# Copyright 2014-2019 Melissa O'Neill <oneill@pcg-random.org>,
#                     and the PCG Project contributors.
#
# Licensed under the Apache License, Version 2.0 (provided in
# LICENSE-APACHE.txt and at http://www.apache.org/licenses/LICENSE-2.0)
# or under the MIT license (provided in LICENSE-MIT.txt and at
# http://opensource.org/licenses/MIT), at your option. This code may not
# be copied, modified, or distributed except according to those terms.
#
# Distributed on an "AS IS" BASIS, WITHOUT WARRANTY OF ANY KIND, either
# express or implied.  See your chosen license for details.
#
# For additional information about the PCG random number generation scheme,
# visit http://www.pcg-random.org/.
if [ '#-9223372036854775808' = "#$(( 9223372036854775807 + 1 ))" ]; then
pcg64si_srandom_r() {
  set -- "$(( $1 ))" 6364136223846793005 1442695040888963407
  pcg_state="$(( (0 * $2 + $3 + $1) * $2 + $3 ))" pcg_max=9223372036854775807
}
pcg64si_random_r() {
  set -- "${pcg_state}" "$(( (pcg_state >> 1) & pcg_max ))"
  pcg_state="$(( pcg_state * 6364136223846793005 + 1442695040888963407 ))"
  pcg_number="$(( (($2 >> (($2 >> 58) + 4)) ^ $1) * -5840758589994634535 ))"
  pcg_number="$(( (((pcg_number >> 1) & pcg_max) >> 42) ^ pcg_number ))"
}
pcg_srand() {
  pcg64si_srandom_r "$1"
}
pcg_rand() {
  # TODO: send patches to http://gondor.apana.org.au/~herbert/dash/
  # XXX(dash): -9223372036854775807 <= $(( -9223372036854775808 ))
  # XXX(dash): -9223372036854775808 <= $(( x )) # x='-9223372036854775808'
  if [ 0 -lt "$#" ]; then  # [0, 2^63 - 1] when $1=-9223372036854775808
    # https://www.pcg-random.org/posts/bounded-rands.html
    set -- "$(( $1 ))"; set -- "$1" "$(( (pcg_max % $1 + 1 % $1) % $1 ))"
    while true; do
      pcg64si_random_r
      pcg_number="$(( pcg_number < 0 ? pcg_max - ~pcg_number : pcg_number ))"
      if [ "$2" -le "${pcg_number}" ]; then
        pcg_number="$(( pcg_number % $1 ))"
        break
      fi
    done
  else
    pcg64si_random_r  # [0 - 2^63, 2^63 - 1] <=> [0, 2^64 - 1]
  fi
}
elif [ '#-2147483648' = "#$(( 2147483647 + 1 ))" ]; then
pcg32si_srandom_r() {
  set -- "$(( $1 ))" 747796405 2891336453
  pcg_state="$(( (0 * $2 + $3 + $1) * $2 + $3 ))" pcg_max=2147483647
}
pcg32si_random_r() {
  set -- "${pcg_state}" "$(( (pcg_state >> 1) & pcg_max ))"
  pcg_state="$(( pcg_state * 747796405 + 2891336453 ))"
  pcg_number="$(( (($2 >> (($2 >> 27) + 3)) ^ $1) * 277803737 ))"
  pcg_number="$(( (((pcg_number >> 1) & pcg_max) >> 21) ^ pcg_number ))"
}
pcg_srand() {
  pcg32si_srandom_r "$1"
}
pcg_rand() {
  if [ 0 -lt "$#" ]; then  # [0, 2^31 - 1] when $1=-2147483648
    set -- "$(( $1 ))"; set -- "$1" "$(( (pcg_max % $1 + 1 % $1) % $1 ))"
    while true; do
      pcg32si_random_r
      pcg_number="$(( pcg_number < 0 ? pcg_max - ~pcg_number : pcg_number ))"
      if [ "$2" -le "${pcg_number}" ]; then
        pcg_number="$(( pcg_number % $1 ))"
        break
      fi
    done
  else
    pcg32si_random_r  # [0 - 2^31, 2^31 - 1] <=> [0, 2^32 - 1]
  fi
}
fi
pcg_clear() {
  unset -v pcg_state pcg_number pcg_max
}
pcg_clear
# PCG Random Number Generation ported to POSIX shell }

# XXX: damn those posix shells which provide no support for the POSIX/C locale
genseed() (
  set -e
  IFS="	' "'!"#$%&()*+,-./:;<=>?@GHIJKLMNOPQRSTUVWXYZ[\]^_`ghijklmnopqrstuvwxyz{|}~'
  s='' i=0
  while [ 8 -gt "${#s}" ]; do
    IFS='' read -r z
    for z in $z; do
      s="${s}${z%%[!0-9A-Fa-f]*}"
    done
  done </dev/urandom
  printf '0x%.8s\n' "${s}"
)

hex2bin() {
  while [ 0 -lt "${#1}" ]; do
    case "$1" in
      ([0-9A-Fa-f][0-9A-Fa-f]*)
        set -- "${1#??}" "$1"
        printf "\\$(printf '%03o' "$(( 0x${2%"$1"} ))")"
        ;;
      (*) set -- "${1#?}"
    esac
  done
}

namespace_hash() {
  # XXX: use a termporary file to detect pipefail?
  { hex2bin "$2"; shift 2; printf '%s' "$*"; } | openssl dgst -"$1" -hex -c
}

# usage: gettime second nanosecond
gettime() {
  set -- "$1" "$2" "$(date "+$1=%s $2=\"\$(format_int %N)\"")"
  case "${3-}" in
    (*" $2="*\ [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]\)*) eval "$3" ;;
    (*" $2="*) eval "${3%%\ *} $2=0" ;;
    (*) eval "$1=\"\$(date '+%s')\"; $2=0"
  esac
}

swap32() {
  eval ": \$(( $1 = (($1 >> 24) & 0xFF) \
                  | (($1 >>  8) & 0xFF00) \
                  | (($1 <<  8) & 0xFF0000) \
                  | (($1 << 24) & 0xFF000000) ))"
}
swap16() {
  eval ": \$(( $1 = (($1 >> 8) & 0xFF) | (($1 << 8) & 0xFF00) ))"
}

format_int() {
  # remove whitespace and leading zeros while preserving signness
  printf '%s\n' "$(( ${1%%[0-9]*}${1#"${1%%[1-9]*}"} + 0 ))"
}

format_uint() {
  # remove whitespace, number sign and leading zeros
  printf '%s\n' "$(( ${1#"${1%%[1-9]*}"} + 0 ))"
}

format_uuid() {
  [ 16 -eq "$#" ] || return
  if [ 1 != "${flg_bin-}" ]; then
    printf '%s%s%s%s-%s%s-%s%s-%s%s-%s%s%s%s%s%s\n' "$@"
  else
    if [ 1 = "${flg_guid-}" ]; then
      set -- "$4" "$3" "$2" "$1" "$6" "$5" "$8" "$7" \
             "$9" "${10}" "${11}" "${12}" "${13}" "${14}" "${15}" "${16}"
    fi
    hex2bin "$*"
  fi
}

# XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
#               ^    ^
# (4 bits) version  variant (2 bits: 10xx, 3 bits: 110x)
check_uuid() (
  set -e
  s="$1" i=0 err='' poo='' ver='' var=''
  while [ 0 -lt "${#s}" ]; do
    case "$(( i += 1 ))" in
      (37) break ;;
      (9|14|19|24) case_in "${s}" '-*'    || err=1 poo="${poo} ${i}" ;;
      (15) case_in "${s}" '[12345678]*'   || err=1 ver="${i}" ;;
      (20) case_in "${s}" '[89ABCDabcd]*' || err=1 var="${i}" ;;
      (*) case_in "${s}" '[0-9A-Fa-f]*'   || err=1 poo="${poo} ${i}"
    esac
    s="${s#?}"
  done
  if [ 36 != "${i}" ]; then
    err=1
  fi
  if [ '' != "${poo}" ]; then
    poo="$(
      set -e
      k=0; for i in $poo; do printf "%$(( i - k ))s" '^'; k="${i}"; done
    )"
    ekho 'UUID contains invalid characters'; ekho "$1"; ekho "${poo}"
  fi
  if [ '' != "${ver}" ]; then
    poo="$(printf "%${ver}s" '^')"
    ekho 'UUID contains invalid version bits'; ekho "$1"; ekho "${poo}"
  fi
  if [ '' != "${var}" ]; then
    poo="$(printf "%${var}s" '^')"
    ekho 'UUID contains invalid variant bits'; ekho "$1"; ekho "${poo}"
  fi
  if [ '' != "${err}" ]; then
    ekho 'UUID must be hexadecimal digits (0-9 A-F a-f) in the form:'
    ekho 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
    die
  fi
)

check_node() {
  { [ "$(( $1 * 2 ))" -eq "${#3}" ] && ! case_in "$3" '*[!0-9A-Fa-f]*'; } \
    || die "node must be $1 bytes ($(( $1 * 2 )) hex digits)"
  check_uint node 0 "$2" "$(( 0x$3 ))"
}

check_seed() {
  if ! { [ 0 -le "$1" ] || [ 0 -ge "$1" ]; }; then
    die "invalid seed number: \"$1\""
  fi
  format_int "$1"
}

check_uint() {
  # FIXME: $3 must be less than 2^(bits - 1)
  if ! [ "$2" -le "$4" ] || ! [ "$3" -ge "$4" ]; then
    die "$1 out of range [$2, $3]: $4"
  fi
  format_uint "$4"
}

need_args() {
  case "$#" in
    (2) die "$1 requires $2 argument(s)" ;;  # e.g. need_args cmd ${2+2} 2
    (3) [ "$3" -eq "$2" ] || die "$1 requires $3 argument(s)" ;;
    (4)
      [ "$3" -le "$2" ] || die "$1 requires at least $3 argument(s)"
      [ "$4" -ge "$2" ] || die "$1 requires at most $4 argument(s)"
      ;;
    (*) die need_args
  esac
}


uuid_v_() {
  [ 1 != "${cfg_32bit}" ] || die 'unable to manipulate 64-bit numbers'
  # ALERT: should not run in subshell

  unset -v epoch_offset max_period max_sequence \
           now now_s now_ns domain identifier period sequence node x
  pcg_clear

  y0="${flg_guid-0}"
  max_node=281474976710655  # 48 bits 0xFFFFFFFFFFFF

  v="$1"; shift
  case "${v}" in
    (1)
      # count of the 100ns intervals
      # from Gregorian Epoch (1582-10-15T00:00:00Z)
      #        to Unix Epoch (1970-01-01T00:00:00Z)
      epoch_offset=122192928000000000
      max_period=1152921504606846975      # 60 bits 0x0FFFFFFFFFFFFFFF
      max_sequence="$(( 0x3FFF >> y0 ))"  # 14 bits 0x3FFF
      ;;
    (2)
      domain="$(check_uint domain 0 255 "$1")"
      identifier="$(check_uint identifier 0 4294967295 "$2")"
      shift 2
      epoch_offset=122192928000000000
      max_period=268435455              # 28 bits 0x0FFFFFFF
      max_sequence="$(( 0x3F >> y0 ))"  #  6 bits 0x3F
      ;;
    (6)
      epoch_offset=122192928000000000
      max_period=1152921504606846975      # 60 bits 0x0FFFFFFFFFFFFFFF
      max_sequence="$(( 0x3FFF >> y0 ))"  # 14 bits 0x3FFF
      ;;
    (*) die uuid_v_
  esac

  if [ 1 = "${cfg_seed+1}" ]; then
    pcg_srand "${cfg_seed}"
  else
    gettime now_s now_ns
    pcg_srand "$(( now_s ^ now_ns ))"  # good enough ^[1]
  fi

  if [ 0 -ge "$#" ] || [ 1 = "${flg_next-}" ]; then
    if [ 1 != "${now_s+1}" ]; then
      gettime now_s now_ns  #[1]: openssl would cost another 10ms for seeding
    fi
    # FIXME: overflow check
    # NOTE: we have no system-wide global lock, don't emulate high resolution
    case "${v}" in
      (1|6) : $(( now = epoch_offset + now_s * 10000000 + now_ns / 100 )) ;;
      (2) : $(( now = (epoch_offset + now_s * 10000000) >> 32 )) ;;
    esac
  fi

  pcg_rand "${max_node} + 1"  # unconditional, more deterministic results
  if [ 3 -gt "$#" ]; then  # state unavailable
    # NOTE: we don't generate a real (and unique?) MAC address
    node="${pcg_number}"
  else
    node="$(check_node 6 "${max_node}" "$3")"
  fi

  pcg_rand "${max_sequence} + 1"
  if [ 2 -gt "$#" ]; then  # node or sequence unknown
    sequence="${pcg_number}"
  else
    # NOTE: unable to detect node change, not going to increment clock sequence
    sequence="$(check_uint sequence 0 "${max_sequence}" "$2")"
  fi

  if [ 1 != "${flg_next-}" ]; then
    if [ 1 -le "$#" ]; then
      now="$(check_uint period 0 "${max_period}" "$1")"
    fi
  else
    if [ 3 -le "$#" ]; then  # state available
      period="$(check_uint period 0 "${max_period}" "$1")"
      # NOTE: presume we are the only generator in service
      if [ "${period}" -eq "${now}" ]; then
        die 'running out of UUID for now'
      fi
      if [ "${period}" -gt "${now}" ]; then  # system clock went backward
        : $(( sequence = (sequence + 1) % max_sequence ))
      fi
    fi
  fi

  if [ upper != "${cfg_case-}" ]; then x=x; else x=X; fi

  if [ 1 = "${flg_decode-}" ]; then
    if [ 2 != "${v}" ]; then
      printf "%u %u %012${x}\\n" "${now}" "${sequence}" "${node}" >&3
    else
      printf "%u %u %u %u %012${x}\\n" "${domain}" "${identifier}" \
             "${now}" "${sequence}" "${node}" >&3
    fi
    exit
  fi

  if [ 2 = "${v}" ]; then
    : $(( now = (now << 32) + identifier ))
    : $(( sequence = (sequence << 8) + domain ))
  fi
  if [ 6 != "${v}" ]; then
    : $(( time_low = now & 0xFFFFFFFF ))
    : $(( time_mid = (now >> 32) & 0xFFFF ))
    : $(( time_high = (v << 12) | ((now >> 48) & 0x0FFF) ))
  else
    : $(( time_low = ((now >> 28) & 0xFFFFFFFF) ))
    : $(( time_mid = (now >> 12) & 0xFFFF ))
    : $(( time_high = (v << 12) | (now & 0x0FFF) ))
  fi
  : $(( y1 = !(${flg_guid-0}) ? 0x8000 : 0xC000 ))
  : $(( y2 = !(${flg_guid-0}) ? 0x3FFF : 0x1FFF ))
  : $(( clk_seq = y1 | (sequence & y2) ))  # include variant bits

  uuid="$(
    set -e
    if [ 11 = "${flg_bin-}${flg_guid-}" ]; then
      swap32 time_low; swap16 time_mid; swap16 time_high
    fi
    printf "%08${x}-%04${x}-%04${x}-%04${x}-%012${x}" \
           "${time_low}" "${time_mid}" "${time_high}" "${clk_seq}" "${node}"
  )"

  if [ 1 != "${flg_bin-}" ]; then
    echo "${uuid}" >&3
  else
    hex2bin "${uuid}" >&3
  fi

  exit  # avoid conflicts with unknown variables
}


#  0                   10                  20                  30
#   0 1 2 3 4 5 6 7 8 9 A B C D E F 0 1 2 3 4 5 6 7 8 9 A B C D E F
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |                          time_low                             |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |           time_mid            |     time_high_and_version     |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |clk_seq_hi_res |  clk_seq_low  |          node (0-1)           |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |                          node (2-5)                           |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
uuid_v1() (
  set -e
  need_args uuid_v1 "$#" 0 3
  uuid_v_ 1 ${1+"$@"}
)


#  0                   10                  20                  30
#   0 1 2 3 4 5 6 7 8 9 A B C D E F 0 1 2 3 4 5 6 7 8 9 A B C D E F
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |                      local_identifier                         |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |           time_mid            |     time_high_and_version     |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |clk_seq_hi_res |    domain     |          node (0-1)           |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |                          node (2-5)                           |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
uuid_v2() (
  set -e
  need_args uuid_v2 "$#" 2 5
  uuid_v_ 2 ${1+"$@"}
)


#  0                   10                  20                  30
#   0 1 2 3 4 5 6 7 8 9 A B C D E F 0 1 2 3 4 5 6 7 8 9 A B C D E F
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |                           time_high                           |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |           time_mid            |     time_low_and_version      |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |clk_seq_hi_res |  clk_seq_low  |          node (0-1)           |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |                          node (2-5)                           |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
uuid_v6() (
  set -e
  need_args uuid_v6 "$#" 0 3
  uuid_v_ 6 ${1+"$@"}
)


#  0                   10                  20                  30
#   0 1 2 3 4 5 6 7 8 9 A B C D E F 0 1 2 3 4 5 6 7 8 9 A B C D E F
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |                          millisecond                          |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |          millisecond          |  ver  |        random1        |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |var$                        random2                            |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |                            random2                            |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
uuid_v7() (
  set -e
  [ 1 != "${cfg_32bit}" ] || die 'unable to manipulate 64-bit numbers'
  need_args uuid_v7 "$#" 0 3

  unset -v max_millisecond max_random1 max_random2 \
           now_s now_ns millisecond random1 random2 x
  pcg_clear

  y0="${flg_guid-0}"
  max_millisecond=281474976710655                # 48 bits 0xFFFFFFFFFFFF
  max_random1=4095                               # 12 bits 0x0FFF
  max_random2="$(( 0x3FFFFFFFFFFFFFFF >> y0 ))"  # 62 bits 0x3FFFFFFFFFFFFFFF

  if [ 1 = "${cfg_seed+1}" ]; then
    pcg_srand "${cfg_seed}"
  else
    gettime now_s now_ns
    pcg_srand "$(( now_s ^ now_ns ))"
  fi

  if [ 0 -ge "$#" ]; then
    if [ 1 != "${now_s+1}" ]; then
      gettime now_s now_ns
    fi
    # FIXME: overflow check
    millisecond="$(( now_s * 1000 + now_ns / 1000000 ))"
  else
    millisecond="$(check_uint millisecond 0 "${max_millisecond}" "$1")"
  fi

  pcg_rand "${max_random1} + 1"
  if [ 2 -gt "$#" ]; then
    random1="${pcg_number}"
  else
    random1="$(check_uint random1 0 "${max_random1}" "$2")"
  fi

  pcg_rand "${max_random2} + 1"
  if [ 3 -gt "$#" ]; then
    random2="${pcg_number}"
  else
    random2="$(check_uint random2 0 "${max_random2}" "$3")"
  fi

  if [ upper != "${cfg_case-}" ]; then x=x; else x=X; fi

  if [ 1 = "${flg_decode-}" ]; then
    printf '%u %u %u\n' "${millisecond}" "${random1}" "${random2}" >&3
    return
  fi

  : $(( y1 = !(${flg_guid-0}) ? 0x8000 : 0xC000 ))
  : $(( y2 = !(${flg_guid-0}) ? 0x3FFF : 0x1FFF ))
  : $(( s1_08 = (millisecond >> 16) & 0xFFFFFFFF ))
  : $(( s2_04 = millisecond & 0xFFFF ))
  : $(( s3_04 = 0x7000 | (random1 & 0x0FFF) ))
  : $(( s4_04 = (y1 | ((random2 >> 48) & y2)) ))
  : $(( s5_12 = random2 & 0xFFFFFFFFFFFF ))

  uuid="$(
    set -e
    if [ 11 = "${flg_bin-}${flg_guid-}" ]; then
      swap32 s1_08; swap16 s2_04; swap16 s3_04
    fi
    printf "%08${x}-%04${x}-%04${x}-%04${x}-%012${x}" \
           "${s1_08}" "${s2_04}" "${s3_04}" "${s4_04}" "${s5_12}"
  )"

  if [ 1 != "${flg_bin-}" ]; then
    echo "${uuid}" >&3
  else
    hex2bin "${uuid}" >&3
  fi
)


#  0                   10                  20                  30
#   0 1 2 3 4 5 6 7 8 9 A B C D E F 0 1 2 3 4 5 6 7 8 9 A B C D E F
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |                        year-month-day                         |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |          hour:minute          |  ver  |        random1        |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |var$          random2          |          node (0-1)           |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#  |                          node (2-5)                           |
#  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#
# This custom layout is designed for:
# - Time-ordred and lexicographically sortable UUIDs.
# - Calendar-based version numbers like 2020.2.2 and 2020-02-02T20:20.
# - Local Object IDs (26-bit randomness, extendable by 48-bit node).
# - Easy to contruct UUIDs even by hand rolling dices.
# 32 bits is enough for counting minutes elapsed since the year 1970 til 9999.
uuid_v8() (
  set -e
  need_args uuid_v8 "$#" 0 6

  unset -v year month day hour minute node1 node2 random1 random2 x

  pcg_clear
  pcg_srand "${cfg_seed-"$(genseed)"}"

  if [ 0 -ge "$#" ]; then
    day="$(date '+year=%Y month=%m day=%d hour=%H minute=%M')"
    eval "${day}"
  else
    year="$(check_uint year 0 9999 "$1")"
    month="$(check_uint month 1 12 "${2-1}")"
    hour="$(check_uint hour 0 23 "${4-0}")"
    minute="$(check_uint minute 0 59 "${5-0}")"
    case "${month}" in
      ([13578]|10|12)
        day="$(check_uint "day of month#${month}" 1 31 "${3-1}")" ;;
      ([469]|11)
        day="$(check_uint "day of month#${month}" 1 30 "${3-1}")" ;;
      (2)
        if [ 0 -ne "$(( year % 100 == 0 ? year % 400 : year % 4 ))" ]; then
          day="$(check_uint "day of month#${month}" 1 28 "${3-1}")"
        else
          day="$(check_uint "day of month#${month}" 1 29 "${3-1}")"
        fi
    esac
  fi
  : $(( year = 0x${year} ))
  : $(( month = 0x${month} ))
  : $(( day = 0x${day} ))
  : $(( hour = 0x${hour} ))
  : $(( minute = 0x${minute} ))

  if [ 6 -gt "$#" ]; then
    #max_node=281474976710655  # 48 bits 0xFFFFFFFFFFFF
    pcg_rand 16777216; node1="${pcg_number}"
    pcg_rand 16777216; node2="${pcg_number}"
  else
    if [ 12 -ne "${#6}" ] || case_in "$6" '*[!0-9A-Fa-f]*'; then
      die "node must be 6 bytes (12 hex digits)"
    fi
    pcg_rand 16777216; pcg_rand 16777216
    node1="$(( 0x${6%??????} ))" node2="$(( 0x${6#??????} ))"
  fi

  if [ upper != "${cfg_case-}" ]; then x=x; else x=X; fi

  if [ 1 = "${flg_decode-}" ]; then
    printf "%x %x %x %x %x %06${x}%06${x}\\n" \
           "${year}" "${month}" "${day}" "${hour}" "${minute}" \
           "${node1}" "${node2}" >&3
    return
  fi

  pcg_rand 0x1000; random1="${pcg_number}"
  pcg_rand 0x4000; random2="${pcg_number}"

  : $(( y1 = !(${flg_guid-0}) ? 0x8000 : 0xC000 ))
  : $(( y2 = !(${flg_guid-0}) ? 0x3FFF : 0x1FFF ))
  : $(( s1_08 = ((year << 16) | (month << 8) | day) & 0xFFFFFFFFFF ))
  : $(( s2_04 = ((hour << 8) | minute) & 0xFFFF ))
  : $(( s3_04 = 0x8000 | (random1 & 0x0FFF) ))
  : $(( s4_04 = (y1 | (random2 & y2)) ))

  uuid="$(
    set -e
    if [ 11 = "${flg_bin-}${flg_guid-}" ]; then
      swap32 s1_08; swap16 s2_04; swap16 s3_04
    fi
    # WTF: mksh does not have printf built-in therefore negative numbers suck
    printf "%04${x}%04${x}-%04${x}-%04${x}-%04${x}-%06${x}%06${x}" \
           "$(( (s1_08 >> 16) & 0xFFFF ))" "$(( s1_08 & 0xFFFF ))" \
           "${s2_04}" "${s3_04}" "${s4_04}" "${node1}" "${node2}"
  )"

  if [ 1 != "${flg_bin-}" ]; then
    echo "${uuid}" >&3
  else
    hex2bin "${uuid}" >&3
  fi
)


uuid_v0() (
  set -e
  need_args uuid_v0 "$#" 0 1

  # generate 32 completely random bytes and make it look like a UUID ?
  if [ 0 -ge "$#" ]; then
    [ 1 != "${flg_decode-}" ] \
      || die "uuid v0 ... unable to work on v0 UUIDs with --decode"
    [ 1 != "${flg_guid-}" ] \
      || die "uuid v0 ... unable to work on v0 UUIDs with --guid"
    bytes="$(
      set -e
      pcg_clear; i=0
      if [ 1 != "${cfg_seed+1}" ] && have openssl; then
        s="$(openssl rand -hex 16)"
        while [ 16 -ge "$(( i += 1 ))" ]; do
          printf " ${cfg_fmt}" "$(( 0x${s%"${s#??}"} ))"
          s="${s#??}"
        done
      else
        seed="${cfg_seed-"$(genseed)"}"
        pcg_srand "${seed}"
        while [ 16 -ge "$(( i += 1 ))" ]; do
          pcg_rand 256
          printf " ${cfg_fmt}" "${pcg_number}"
        done
      fi
    )"
    format_uuid $bytes >&3 || die 'O MY RNG GOD'
    return
  fi

  # 8-4-4-4-12 XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
  check_uuid "$1"
  IFS='-'; set -- $1; unset -v IFS

  case "$3" in
    ([12345678]???) version="${3%???}" ;;
    (*) die uuid_v0
  esac
  case "$4" in
    ([89ABab]???) variant=1 ;;
    ([CDcd]???) variant=2 ;;
    (*) die uuid_v0
  esac

  if [ 1 = "${variant}" ]; then y0=0; else y0=1; fi
  if [ upper != "${cfg_case-}" ]; then x=x; else x=X; fi

  case "${version}" in
    ([345])
      if [ 1 != "${flg_decode-}" ]; then
        die "uuid v0 ... unable to work on v${version} UUIDs without --decode"
      else
        echo "uuid_version=${version}" >&3
        echo "uuid_variant=${variant}" >&3
      fi
      ;;
    (2)
      [ 1 != "${cfg_32bit}" ] || die 'unable to manipulate 64-bit numbers'
      s="$(
        set -e
        printf "%u %u %u %u %06${x}%06${x}" \
               "$(( 0x${4#??} ))" \
               "$(( 0x$1 ))" \
               "$(( (0x${3#?} << 16) | 0x$2 ))" \
               "$(( 0x${4%??} & (0x3F >> y0) ))" \
               "$(( 0x${5%??????} ))" "$(( 0x${5#??????} ))"
      )"
      if [ 1 != "${flg_decode-}" ]; then
        "uuid_v${version}" $s
      else
        set -- "${version}" "${variant}" $s
        s="$(printf 'uuid_%s=%%s\n' version variant \
                                    domain identifier period sequence node)"
        printf "${s}\\n" "$@" >&3
      fi
      ;;
    (1|6)
      [ 1 != "${cfg_32bit}" ] || die 'unable to manipulate 64-bit numbers'
      s="$(
        set -e
        if [ 1 = "${version}" ]; then
          printf '%u\n' "$(( (0x${3#?} << 48) | (0x$2 << 32) | 0x$1 ))"
        else
          printf '%u\n' "$(( (0x$1 << 28) | (0x$2 << 12) | 0x${3#?} ))"
        fi
        printf '%u\n' "$(( 0x$4 & (0x3FFF >> y0) ))"
        printf "%06${x}%06${x}\\n" "$(( 0x${5%??????} ))" "$(( 0x${5#??????} ))"
      )"
      if [ 1 != "${flg_decode-}" ]; then
        "uuid_v${version}" $s
      else
        set -- "${version}" "${variant}" $s
        s="$(printf 'uuid_%s=%%s\n' version variant period sequence node)"
        printf "${s}\\n" "$@" >&3
      fi
      ;;
    (7)
      [ 1 != "${cfg_32bit}" ] || die 'unable to manipulate 64-bit numbers'
      s="$(
        set -e
        printf '%u %u %u' \
               "$(( (0x$1 << 16) | 0x$2 ))" \
               "$(( 0x${3#?} ))" \
               "$(( ((0x$4 & (0x3FFF >> y0)) << 48) | 0x$5 ))"
      )"
      if [ 1 != "${flg_decode-}" ]; then
        "uuid_v${version}" $s
      else
        set -- "${version}" "${variant}" $s
        s="$(printf 'uuid_%s=%%s\n' version variant \
                                    millisecond random1 random2)"
        printf "${s}\\n" "$@" >&3
      fi
      ;;
    (8)
      s="$(
        set -e
        printf "%x %x %x %x %x %06${x}%06${x}" \
               "$(( (0x$1 >> 16) & 0xFFFF ))" \
               "$(( (0x$1 >> 8) & 0xFF ))" \
               "$(( 0x$1 & 0xFF ))" \
               "$(( (0x$2 >> 8) & 0xFF ))" \
               "$(( 0x$2 & 0xFF ))" \
               "$(( 0x${5%??????} ))" "$(( 0x${5#??????} ))"
      )"
      if [ 1 != "${flg_decode-}" ]; then
        "uuid_v${version}" $s
      else
        set -- "${version}" "${variant}" $s
        s="$(printf 'uuid_%s=%%s\n' version variant \
                                    year month day hour minute node)"
        printf "${s}\\n" "$@" >&3
      fi
  esac
)


uuid_v3() (
  set -e
  [ 1 != "${flg_decode-}" ] || die '--decode does not work on "uuid v3 ..."'
  need_args uuid_v3 "$#" 2 "$#"
  check_uuid "$1"
  bytes="$(
    set -e
    hash="$(namespace_hash md5 "$@")"
    : $(( y1 = !(${flg_guid-0}) ? 0x80 : 0xC0 ))
    : $(( y2 = !(${flg_guid-0}) ? 0x3F : 0x1F ))
    IFS=':' i=0
    for x in ${hash##*' '}; do
      case "$(( i += 1 ))" in
        (7) printf " ${cfg_fmt}" "$(( 0x30 | (0x${x} & 0x0F) ))" ;;
        (9) printf " ${cfg_fmt}" "$((   y1 | (0x${x} & y2  ) ))" ;;
        (*) printf " ${cfg_fmt}" "$((         0x${x}         ))"
      esac
    done
  )"
  format_uuid $bytes >&3 || die 'openssl fouled things up'
)


uuid_v5() (
  set -e
  [ 1 != "${flg_decode-}" ] || die '--decode does not work on "uuid v5 ..."'
  need_args uuid_v5 "$#" 2 "$#"
  check_uuid "$1"
  bytes="$(
    set -e
    hash="$(namespace_hash sha1 "$@")"
    : $(( y1 = !(${flg_guid-0}) ? 0x80 : 0xC0 ))
    : $(( y2 = !(${flg_guid-0}) ? 0x3F : 0x1F ))
    IFS=':' i=0
    for x in ${hash##*' '}; do
      case "$(( i += 1 ))" in
        (17) break ;;
        (7) printf " ${cfg_fmt}" "$(( 0x50 | (0x${x} & 0x0F) ))" ;;
        (9) printf " ${cfg_fmt}" "$((   y1 | (0x${x} & y2  ) ))" ;;
        (*) printf " ${cfg_fmt}" "$((         0x${x}         ))"
      esac
    done
  )"
  format_uuid $bytes >&3 || die 'openssl fouled things up'
)


uuid_v4() (
  set -e
  [ 1 != "${flg_decode-}" ] || die '--decode does not work on "uuid v4 ..."'
  need_args uuid_v4 "$#" 0 1
  [ 0 -ge "$#" ] || [ 0 -lt "$1" ] || die "invalid count of UUIDs: \"$1\""

  pcg_clear
  seed="${cfg_seed-}"
  if [ 1 = "${seed:+1}" ]; then
    pcg_srand "${seed}"
  elif ! have openssl; then
    seed="$(genseed)"
    pcg_srand "${seed}"
  fi
  : $(( y1 = !(${flg_guid-0}) ? 0x80 : 0xC0 ))
  : $(( y2 = !(${flg_guid-0}) ? 0x3F : 0x1F ))

  count="${1-1}"
  while [ 0 -le "$(( count -= 1 ))" ]; do
    i=0
    state="$(
      set -e
      printf "bytes='"
      if [ 1 != "${seed:+1}" ]; then
        s="$(openssl rand -hex 16)"
        while [ 16 -ge "$(( i += 1 ))" ]; do
          b="$(( 0x${s%"${s#??}"} ))"
          s="${s#??}"
          case "${i}" in
            (7) printf " ${cfg_fmt}" "$(( 0x40 | (b & 0x0F) ))" ;;
            (9) printf " ${cfg_fmt}" "$((   y1 | (b & y2  ) ))" ;;
            (*) printf " ${cfg_fmt}" "${b}"
          esac
        done
        printf "'"
      else
        while [ 16 -ge "$(( i += 1 ))" ]; do
          pcg_rand 256
          case "${i}" in
            (7) printf " ${cfg_fmt}" "$(( 0x40 | (pcg_number & 0x0F) ))" ;;
            (9) printf " ${cfg_fmt}" "$((   y1 | (pcg_number & y2  ) ))" ;;
            (*) printf " ${cfg_fmt}" "${pcg_number}"
          esac
        done
        printf "' pcg_state=%s" "${pcg_state}"
      fi
    )"
    eval "${state}"
    format_uuid $bytes >&3 || die 'O MY RNG GOD'
  done
)


trap '[ 0 -eq "$?" ] || die "uuid.sh exited abnormally"' EXIT

# parse arguments
#{
  unset -v flg_bin flg_guid flg_decode \
           cfg_ver cfg_case cfg_fmt cfg_seed cfg_32bit

  arg_x='' arg_n=0
  arg_push() {
    eval "arg_$(( arg_n += 1 ))=\"\$1\"; arg_x=\"\${arg_x} arg_\${arg_n}\""
  }

  arg='' argi=0 argo='' argp=hbdgnlu
  while [ 0 -lt "$#" ]; do
    : $(( argi += 1 ))
    arg="$1"; shift
    while true; do
      case "${arg}" in
        (-["${argp}"]?*) argo="${arg#-}" ;;
        (-h|--help) help >&3; exit ;;
        (-b|--binary) flg_bin=1 ;;
        (-d|--decode) flg_decode=1 ;;
        (-g|--guid) flg_guid=1 ;;
        (-n|--next) flg_next=1 ;;
        (-l|--lowercase) cfg_case=lower ;;
        (-u|--uppercase) cfg_case=upper ;;
        (--) break 2 ;;
        (-s|--seed) need_args "${arg}" ${1+1} 1
          cfg_seed="$(check_seed "$1")"; shift ;;
        (-s?*) cfg_seed="$(check_seed "${arg#??}")" ;;
        (--seed=*) cfg_seed="$(check_seed "${arg#*=}")" ;;
        (-[!0-9]*|-[0-9]*[!0-9]*)  # excluding "-" and negative integers
          die "unrecognized option at #${argi}: \"${arg}\"" ;;
        (*) arg_push "${arg}"
      esac
      case "${argo}" in
        ('') break ;;
        (-*) die "unrecognized option at #${argi}: \"--\"" ;;
        ([!"${argp}"]*) arg="-${argo}"; argo='' ;;
        (*) arg="-${argo%"${argo#?}"}"; argo="${argo#?}"
      esac
    done
  done
  unset -v arg argi argo argp

  arg_x="set -- ${arg_x:+"$(printf ' "${%s}"' $arg_x)"} \${1+\"\$@\"}
         unset -f arg_push; unset -v arg_n arg_x ${arg_x}"
  eval "${arg_x}"

  if [ upper != "${cfg_case-}" ]; then
    cfg_fmt='%02x'
  else
    cfg_fmt='%02X'
  fi
  if [ 9223372036854775807 != "$(( 9223372036854775807 ))" ]; then
    cfg_32bit=1  # TODO: try bit twiddling
  else
    cfg_32bit=0
  fi
#}

# main
#{
  if [ 0 -lt "$#" ]; then
    cfg_ver="$1"; shift
  else
    cfg_ver=v4
  fi
  case "${cfg_ver}" in
    (v[012345678]) "uuid_${cfg_ver}" ${1+"$@"} ;;
    (*) help; echo; die "invalid UUID version: \"${cfg_ver}\""
  esac
#}
